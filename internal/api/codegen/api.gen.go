// Package codegen provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package codegen

import (
	"context"
	"fmt"
	"net/http"
	"time"

	"github.com/gorilla/mux"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// AuthForm defines model for AuthForm.
type AuthForm struct {
	Login string `json:"login"`
	Pswd  string `json:"pswd"`
}

// DocsListResponse defines model for DocsListResponse.
type DocsListResponse struct {
	Docs *[]DocumentItem `json:"docs,omitempty"`
}

// DocumentItem defines model for DocumentItem.
type DocumentItem struct {
	Created *time.Time `json:"created,omitempty"`
	File    *bool      `json:"file,omitempty"`
	Grant   *[]string  `json:"grant,omitempty"`
	Id      *string    `json:"id,omitempty"`
	Mime    *string    `json:"mime,omitempty"`
	Name    *string    `json:"name,omitempty"`
	Public  *bool      `json:"public,omitempty"`
}

// Envelope Top-level envelope. Поля присутствуют только если заполнены.
type Envelope struct {
	Data  *map[string]interface{} `json:"data"`
	Error *ErrorObj               `json:"error,omitempty"`

	// Response Подтверждение действий (простые ответы)
	Response *map[string]interface{} `json:"response"`
}

// ErrorObj defines model for ErrorObj.
type ErrorObj struct {
	Code int    `json:"code"`
	Text string `json:"text"`
}

// RegisterRequest defines model for RegisterRequest.
type RegisterRequest struct {
	// Login Логин нового пользователя, минимальная длина 8, латиница и цифры
	Login string `json:"login"`

	// Pswd Пароль нового пользователя (валидация на сервере)
	Pswd string `json:"pswd"`
}

// UploadMeta defines model for UploadMeta.
type UploadMeta struct {
	File   bool      `json:"file"`
	Grant  *[]string `json:"grant,omitempty"`
	Mime   *string   `json:"mime,omitempty"`
	Name   string    `json:"name"`
	Public *bool     `json:"public,omitempty"`
}

// ListDocumentsParams defines parameters for ListDocuments.
type ListDocumentsParams struct {
	// Login Опциональное поле. Если не указано — то список своих
	Login *string `form:"login,omitempty" json:"login,omitempty"`

	// Key Filter column name
	Key *string `form:"key,omitempty" json:"key,omitempty"`

	// Value Filter value
	Value *string `form:"value,omitempty" json:"value,omitempty"`
	Limit *int    `form:"limit,omitempty" json:"limit,omitempty"`
}

// UploadDocumentMultipartBody defines parameters for UploadDocument.
type UploadDocumentMultipartBody struct {
	// File Optional FILE payload.
	File *openapi_types.File `json:"file"`

	// Json Optional JSON payload (free form).
	Json *string    `json:"json"`
	Meta UploadMeta `json:"meta"`
}

// AuthenticateUserFormdataRequestBody defines body for AuthenticateUser for application/x-www-form-urlencoded ContentType.
type AuthenticateUserFormdataRequestBody = AuthForm

// UploadDocumentMultipartRequestBody defines body for UploadDocument for multipart/form-data ContentType.
type UploadDocumentMultipartRequestBody UploadDocumentMultipartBody

// RegisterUserJSONRequestBody defines body for RegisterUser for application/json ContentType.
type RegisterUserJSONRequestBody = RegisterRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Завершение авторизованной сессии пользователя
	// (DELETE /api/auth)
	LogoutUser(w http.ResponseWriter, r *http.Request)
	// Аутентификация пользователя
	// (POST /api/auth)
	AuthenticateUser(w http.ResponseWriter, r *http.Request)
	// Получение списка документов пользователя
	// (GET /api/docs)
	ListDocuments(w http.ResponseWriter, r *http.Request, params ListDocumentsParams)
	// Получение списка документов (только заголовки)
	// (HEAD /api/docs)
	HeadDocuments(w http.ResponseWriter, r *http.Request)
	// Загрузка нового документа пользователем
	// (POST /api/docs)
	UploadDocument(w http.ResponseWriter, r *http.Request)
	// Удаление документа пользователя
	// (DELETE /api/docs/{id})
	DeleteDocument(w http.ResponseWriter, r *http.Request, id string)
	// Получение одного документа (файл или JSON)
	// (GET /api/docs/{id})
	GetDocument(w http.ResponseWriter, r *http.Request, id string)
	// Получение заголовков одного документа
	// (HEAD /api/docs/{id})
	HeadDocument(w http.ResponseWriter, r *http.Request, id string)
	// Регистрация нового пользователя (только с токеном администратора)
	// (POST /api/register)
	RegisterUser(w http.ResponseWriter, r *http.Request)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// LogoutUser operation middleware
func (siw *ServerInterfaceWrapper) LogoutUser(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LogoutUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// AuthenticateUser operation middleware
func (siw *ServerInterfaceWrapper) AuthenticateUser(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AuthenticateUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListDocuments operation middleware
func (siw *ServerInterfaceWrapper) ListDocuments(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDocumentsParams

	// ------------- Optional query parameter "login" -------------

	err = runtime.BindQueryParameter("form", true, false, "login", r.URL.Query(), &params.Login)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "login", Err: err})
		return
	}

	// ------------- Optional query parameter "key" -------------

	err = runtime.BindQueryParameter("form", true, false, "key", r.URL.Query(), &params.Key)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "key", Err: err})
		return
	}

	// ------------- Optional query parameter "value" -------------

	err = runtime.BindQueryParameter("form", true, false, "value", r.URL.Query(), &params.Value)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "value", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListDocuments(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HeadDocuments operation middleware
func (siw *ServerInterfaceWrapper) HeadDocuments(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadDocuments(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UploadDocument operation middleware
func (siw *ServerInterfaceWrapper) UploadDocument(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadDocument(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteDocument operation middleware
func (siw *ServerInterfaceWrapper) DeleteDocument(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", mux.Vars(r)["id"], &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteDocument(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetDocument operation middleware
func (siw *ServerInterfaceWrapper) GetDocument(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", mux.Vars(r)["id"], &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetDocument(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// HeadDocument operation middleware
func (siw *ServerInterfaceWrapper) HeadDocument(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", mux.Vars(r)["id"], &id, runtime.BindStyledParameterOptions{Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadDocument(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RegisterUser operation middleware
func (siw *ServerInterfaceWrapper) RegisterUser(w http.ResponseWriter, r *http.Request) {

	ctx := r.Context()

	ctx = context.WithValue(ctx, BearerAuthScopes, []string{})

	r = r.WithContext(ctx)

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RegisterUser(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{})
}

type GorillaServerOptions struct {
	BaseURL          string
	BaseRouter       *mux.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r *mux.Router) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r *mux.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, GorillaServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options GorillaServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = mux.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.HandleFunc(options.BaseURL+"/api/auth", wrapper.LogoutUser).Methods("DELETE")

	r.HandleFunc(options.BaseURL+"/api/auth", wrapper.AuthenticateUser).Methods("POST")

	r.HandleFunc(options.BaseURL+"/api/docs", wrapper.ListDocuments).Methods("GET")

	r.HandleFunc(options.BaseURL+"/api/docs", wrapper.HeadDocuments).Methods("HEAD")

	r.HandleFunc(options.BaseURL+"/api/docs", wrapper.UploadDocument).Methods("POST")

	r.HandleFunc(options.BaseURL+"/api/docs/{id}", wrapper.DeleteDocument).Methods("DELETE")

	r.HandleFunc(options.BaseURL+"/api/docs/{id}", wrapper.GetDocument).Methods("GET")

	r.HandleFunc(options.BaseURL+"/api/docs/{id}", wrapper.HeadDocument).Methods("HEAD")

	r.HandleFunc(options.BaseURL+"/api/register", wrapper.RegisterUser).Methods("POST")

	return r
}
